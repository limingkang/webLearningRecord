<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>骨架梳理 | 前端学习</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="努力学习">
    <link rel="preload" href="/webLearningRecord/assets/css/0.styles.32aa171d.css" as="style"><link rel="preload" href="/webLearningRecord/assets/js/app.bdc4d5ac.js" as="script"><link rel="preload" href="/webLearningRecord/assets/js/2.1a231426.js" as="script"><link rel="preload" href="/webLearningRecord/assets/js/6.d3f0121d.js" as="script"><link rel="prefetch" href="/webLearningRecord/assets/js/10.6c45162c.js"><link rel="prefetch" href="/webLearningRecord/assets/js/11.f477fe3a.js"><link rel="prefetch" href="/webLearningRecord/assets/js/12.719839a4.js"><link rel="prefetch" href="/webLearningRecord/assets/js/13.2e776131.js"><link rel="prefetch" href="/webLearningRecord/assets/js/14.6961d267.js"><link rel="prefetch" href="/webLearningRecord/assets/js/15.94790cc9.js"><link rel="prefetch" href="/webLearningRecord/assets/js/16.5c5eee38.js"><link rel="prefetch" href="/webLearningRecord/assets/js/17.025ef091.js"><link rel="prefetch" href="/webLearningRecord/assets/js/18.ef4a8780.js"><link rel="prefetch" href="/webLearningRecord/assets/js/19.ec38cef5.js"><link rel="prefetch" href="/webLearningRecord/assets/js/20.f6711983.js"><link rel="prefetch" href="/webLearningRecord/assets/js/21.0cef24fe.js"><link rel="prefetch" href="/webLearningRecord/assets/js/22.9224a013.js"><link rel="prefetch" href="/webLearningRecord/assets/js/23.ec789df6.js"><link rel="prefetch" href="/webLearningRecord/assets/js/24.3bce65fe.js"><link rel="prefetch" href="/webLearningRecord/assets/js/25.f4d74d85.js"><link rel="prefetch" href="/webLearningRecord/assets/js/26.70ee71fc.js"><link rel="prefetch" href="/webLearningRecord/assets/js/27.39bdc05b.js"><link rel="prefetch" href="/webLearningRecord/assets/js/28.31277bb6.js"><link rel="prefetch" href="/webLearningRecord/assets/js/29.97b7aecc.js"><link rel="prefetch" href="/webLearningRecord/assets/js/3.9f1b9f7a.js"><link rel="prefetch" href="/webLearningRecord/assets/js/30.bcf3c482.js"><link rel="prefetch" href="/webLearningRecord/assets/js/31.e07b317a.js"><link rel="prefetch" href="/webLearningRecord/assets/js/32.1352871c.js"><link rel="prefetch" href="/webLearningRecord/assets/js/33.f98a7f1c.js"><link rel="prefetch" href="/webLearningRecord/assets/js/34.3797f037.js"><link rel="prefetch" href="/webLearningRecord/assets/js/4.217c5e32.js"><link rel="prefetch" href="/webLearningRecord/assets/js/5.bd81a106.js"><link rel="prefetch" href="/webLearningRecord/assets/js/7.c3e5ebfe.js"><link rel="prefetch" href="/webLearningRecord/assets/js/8.62631f20.js"><link rel="prefetch" href="/webLearningRecord/assets/js/9.094f8da5.js">
    <link rel="stylesheet" href="/webLearningRecord/assets/css/0.styles.32aa171d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/webLearningRecord/" class="home-link router-link-active"><!----> <span class="site-name">前端学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/limingkang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/limingkang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>浏览器工作原理和实践</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/browser-theory/chromeConstruct.html" class="sidebar-link">chrome架构</a></li><li><a href="/webLearningRecord/browser-theory/other.html" class="sidebar-link">缓存和安全</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>微前端架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/web-consttruct/singleSpa.html" class="sidebar-link">single-spa方式实现</a></li><li><a href="/webLearningRecord/web-consttruct/mySingleSpa.html" class="sidebar-link">自己实现一个微前端</a></li><li><a href="/webLearningRecord/web-consttruct/mircoapp.html" class="sidebar-link">microapp</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>前端性能监控</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/web-observe/web-observe.html" class="sidebar-link">构建前端性能监控</a></li><li><a href="/webLearningRecord/web-observe/user-behavior.html" class="sidebar-link">用户行为录制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>vue2源码分析</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/vue-analyze/vue2.html" class="sidebar-link">初始化过程</a></li><li><a href="/webLearningRecord/vue-analyze/components.html" class="sidebar-link">组件化</a></li><li><a href="/webLearningRecord/vue-analyze/reactive.html" class="sidebar-link">响应式原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>包管理</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/bundle/analysize.html" class="sidebar-link">rollup</a></li><li><a href="/webLearningRecord/bundle/pnpm.html" class="sidebar-link">pnpm</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active open"><span>vite</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/vite/prelearn.html" class="sidebar-link">基础知识</a></li><li><a href="/webLearningRecord/vite/analysize.html" class="active sidebar-link">源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/webLearningRecord/vite/analysize.html#骨架梳理" class="sidebar-link">骨架梳理</a></li><li class="sidebar-sub-header"><a href="/webLearningRecord/vite/analysize.html#vite快还是慢" class="sidebar-link">vite快还是慢</a></li><li class="sidebar-sub-header"><a href="/webLearningRecord/vite/analysize.html#vite使用esbuild" class="sidebar-link">vite使用esbuild</a></li><li class="sidebar-sub-header"><a href="/webLearningRecord/vite/analysize.html#优化" class="sidebar-link">优化</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>react浅析</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/react/react.html" class="sidebar-link">react初探</a></li><li><a href="/webLearningRecord/react/two.html" class="sidebar-link">react架构实现</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>经常忘记</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/forget/one.html" class="sidebar-link">JavaScript</a></li><li><a href="/webLearningRecord/forget/two.html" class="sidebar-link">TypeScript</a></li><li><a href="/webLearningRecord/forget/three.html" class="sidebar-link">CSS</a></li><li><a href="/webLearningRecord/forget/four.html" class="sidebar-link">Node</a></li><li><a href="/webLearningRecord/forget/five.html" class="sidebar-link">经常使用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>笔试题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/algorithm/one.html" class="sidebar-link">算法</a></li><li><a href="/webLearningRecord/algorithm/two.html" class="sidebar-link">手写函数</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webLearningRecord/" class="sidebar-heading clickable router-link-active"><span>随笔</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webLearningRecord/think/mess.html" class="sidebar-link">杂谈</a></li><li><a href="/webLearningRecord/think/css.html" class="sidebar-link">css方法论</a></li><li><a href="/webLearningRecord/think/svelte.html" class="sidebar-link">svelte</a></li><li><a href="/webLearningRecord/think/frame.html" class="sidebar-link">框架</a></li><li><a href="/webLearningRecord/think/outer.html" class="sidebar-link">基础文章</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="骨架梳理"><a href="#骨架梳理" class="header-anchor">#</a> 骨架梳理</h2> <blockquote><p><code>Vite</code> 是一种新型的前端构建工具，能够显著提升前端开发体验。</p></blockquote> <p>总结起来<code>vite</code> 通过 <code>connect</code> 库提供开发服务器，通过中间件机制实现多项开发服务器配置。而 <code>vite</code> 在本地开发时没有借助 <code>webpack</code> 或是 <code>rollup</code> 这样的
打包工具，而是通过调度内部 <code>plugin</code> 实现了文件的转译，从而达到小而快的效果</p> <p>本文阅读的 <code>Vite</code> 源码版本是 <code>2.8.0-beta.3</code>，如果你想要和我一起阅读的话，你可以在这个地址下载 <a href="https://github.com/vitejs/vite" target="_blank" rel="noopener noreferrer">Vite 源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>我们先来看看 <code>Vite</code> 这个包的项目目录
<img src="/webLearningRecord/assets/img/eight.7cf155be.jpeg" alt="image"></p> <p>这是一个集成管理的项目，其核心就是在 <code>packages</code> 里面的几个包（如下）</p> <table><thead><tr><th>包名</th> <th>作用</th></tr></thead> <tbody><tr><td><code>vite</code></td> <td><code>Vite</code> 主库，负责 <code>Vite</code> 项目的本地开发（插件调度）和生产产物构建（Rollup 调度）</td></tr> <tr><td><code>create-vite</code></td> <td>用于创建新的 <code>Vite</code> 项目，内部存放了多个框架（如 <code>react、vue</code>）的初始化模板</td></tr> <tr><td><code>plugin-vue</code></td> <td><code>Vite</code> 官方插件，用于提供 Vue 3 单文件组件支持</td></tr> <tr><td><code>plugin-vue-jsx</code></td> <td><code>Vite</code> 官方插件，用于提供 Vue 3 JSX 支持（通过 专用的 Babel 转换插件）。</td></tr> <tr><td><code>plugin-react</code></td> <td><code>Vite</code> 官方插件，用于提供完整的 React 支持</td></tr> <tr><td><code>plugin-legacy</code></td> <td><code>Vite</code> 官方插件，用于为打包后的文件提供传统浏览器兼容性支持</td></tr> <tr><td><code>playground</code></td> <td><code>Vite</code> 内置的一些测试用例及 Demo</td></tr></tbody></table> <p>重点说下 <code>vite</code> 本地开发服务命令 —— <code>vite / vite dev / vite serve</code>。</p> <h3 id="vite-dev"><a href="#vite-dev" class="header-anchor">#</a> vite dev</h3> <p><code>vite dev</code> 调用了内部的 <code>createServer</code> 方法创建了一个服务，这个服务利用中间件（第三方）支持了多种能力（如
<code>跨域</code>、<code>静态文件服务器</code>等），并且内部创建了 <code>watcher</code> 持续监听着文件的变更，进行实时编译和热重载;而 <code>createServer</code> 做的
事情就是我们需要关注的核心逻辑</p> <p>在 <code>createServer</code> 方法中，首先进行了对配置的收集工作 —— <code>resolveConfig</code>,可以直接参照
<a href="https://cn.vitejs.dev/config/#root" target="_blank" rel="noopener noreferrer">Vite 官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看支持的配置项</p> <p><code>resolveConfig</code> 的第一步就是加载项目目录的配置文件，如果没有指定配置文件位置，会自动在根目录下寻找 <code>vite.config.js</code>、
<code>vite.config.mjs</code>、<code>vite.config.ts</code>、<code>vite.config.cjs</code>,如果没有找到配置文件，则直接会中止程序</p> <blockquote><p><code>vite</code> 项目初始化时，会在项目根目录下自动生成 <code>vite.config.js</code> 配置文件。</p></blockquote> <p>在读取配置文件后，会将配置文件和初始化配置（优先级更高，有部分配置来自于命令行参数）进行合并，然后得到一份配置。（如下图）
<img src="/webLearningRecord/assets/img/nine.9dc441d4.jpeg" alt="image"></p> <h3 id="配置收集-resolveconfig"><a href="#配置收集-resolveconfig" class="header-anchor">#</a> 配置收集 - <code>resolveConfig</code></h3> <p>在 <code>createServer</code> 的开头，调用了 <code>resolveConfig</code> 函数，进行配置收集</p> <ul><li>首先<code>resolveConfig</code> 内部处理了插件排序规则，对应下面的排序规则
<img src="/webLearningRecord/assets/img/ten.b7e70d77.png" alt="image">
在后续处理的过程中，插件将按照对应的排序规则先后执行，这样能够让插件更好地工作在各个生命周期节点</li></ul> <h4 id="合并插件配置"><a href="#合并插件配置" class="header-anchor">#</a> 合并插件配置</h4> <p>在插件排序完成后，<code>vite</code> 的 <code>插件</code> 暴露了一个配置 <code>config</code> 字段，可以通过设置该属性，使插件能够新增或改写 <code>vite</code> 的一
些配置。（如下图）
<img src="/webLearningRecord/assets/img/11.367fdbcf.png" alt="image"></p> <h4 id="处理-alias"><a href="#处理-alias" class="header-anchor">#</a> 处理 alias</h4> <p>然后，<code>resolveConfig</code> 内部处理了 <code>alias</code> 的逻辑，将指定的 <code>alias</code> 替换成对应的路径。
<img src="/webLearningRecord/assets/img/12.9651e9dd.png" alt="image"></p> <h4 id="读取环境变量配置"><a href="#读取环境变量配置" class="header-anchor">#</a> 读取环境变量配置</h4> <p>接下来，<code>resolveConfig</code> 内部找到 <code>env</code> 的配置目录（默认为根目录），然后在目录中读取对应的 <code>env</code> 环境变量配置文件。我们可以
看看内部的读取规则优先级（如下图）
<img src="/webLearningRecord/assets/img/13.0192a0cc.png" alt="image">
可以看出，读取的优先级分别是 <code>.env.[mode].local</code>、<code>.env.[mode]</code>。如果不存在对应 <code>mode</code> 的配置文件，则会尝试去寻
找 <code>.env.local</code>、<code>.env</code> 配置文件，读取到配置文件后，使用 <code>doteenv</code> 将环境变量写入到项目中；如果这些环境变量配置文
件都不存在的话，则会返回一个空对象,该环境变量配置文件并不影响项目运行，所以不配置也没有什么影响。</p> <h4 id="导出配置"><a href="#导出配置" class="header-anchor">#</a> 导出配置</h4> <p>接下来，<code>vite</code> 初始化了构建配置，也就是文档中的 <code>build</code> 属性，详情可以参照
<a href="https://cn.vitejs.dev/config/#build-target" target="_blank" rel="noopener noreferrer">构建选项文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <img src="/webLearningRecord/assets/img/14.10da60a2.png" alt="image">
最后，<code>resolveConfig</code> 处理了一些 <code>publicDir</code>、<code>cacheDir</code> 目录后，导出了下面这份配置。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> resolved<span class="token operator">:</span> ResolvedConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>config<span class="token punctuation">,</span>
    configFile<span class="token operator">:</span> configFile <span class="token operator">?</span> <span class="token function">normalizePath</span><span class="token punctuation">(</span>configFile<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    configFileDependencies<span class="token punctuation">,</span>
    inlineConfig<span class="token punctuation">,</span>
    root<span class="token operator">:</span> resolvedRoot<span class="token punctuation">,</span>
    base<span class="token operator">:</span> <span class="token constant">BASE_URL</span><span class="token punctuation">,</span>
    resolve<span class="token operator">:</span> resolveOptions<span class="token punctuation">,</span>
    publicDir<span class="token operator">:</span> resolvedPublicDir<span class="token punctuation">,</span>
    cacheDir<span class="token punctuation">,</span>
    command<span class="token punctuation">,</span>
    mode<span class="token punctuation">,</span>
    isProduction<span class="token punctuation">,</span>
    plugins<span class="token operator">:</span> userPlugins<span class="token punctuation">,</span>
    server<span class="token punctuation">,</span>
    build<span class="token operator">:</span> resolvedBuildOptions<span class="token punctuation">,</span>
    preview<span class="token operator">:</span> <span class="token function">resolvePreviewOptions</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>preview<span class="token punctuation">,</span> server<span class="token punctuation">)</span><span class="token punctuation">,</span>
    env<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>userEnv<span class="token punctuation">,</span>
      <span class="token constant">BASE_URL</span><span class="token punctuation">,</span>
      <span class="token constant">MODE</span><span class="token operator">:</span> mode<span class="token punctuation">,</span>
      <span class="token constant">DEV</span><span class="token operator">:</span> <span class="token operator">!</span>isProduction<span class="token punctuation">,</span>
      <span class="token constant">PROD</span><span class="token operator">:</span> isProduction
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">assetsInclude</span><span class="token punctuation">(</span><span class="token parameter">file<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token constant">DEFAULT_ASSETS_RE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">assetsFilter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    logger<span class="token punctuation">,</span>
    packageCache<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    createResolver<span class="token punctuation">,</span>
    optimizeDeps<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>config<span class="token punctuation">.</span>optimizeDeps<span class="token punctuation">,</span>
      esbuildOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
        keepNames<span class="token operator">:</span> config<span class="token punctuation">.</span>optimizeDeps<span class="token operator">?.</span>keepNames<span class="token punctuation">,</span>
        preserveSymlinks<span class="token operator">:</span> config<span class="token punctuation">.</span>resolve<span class="token operator">?.</span>preserveSymlinks<span class="token punctuation">,</span>
        <span class="token operator">...</span>config<span class="token punctuation">.</span>optimizeDeps<span class="token operator">?.</span>esbuildOptions
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    worker<span class="token operator">:</span> resolvedWorkerOptions
  <span class="token punctuation">}</span>
</code></pre></div><p><img src="/webLearningRecord/assets/img/15.d3dbdc4c.png" alt="image"> <code>resolveConfig</code> 内部还有一些额外的工作处理，主要是收集内部插件集合（如下图），还有配置一些废弃选项警告信息</p> <h3 id="本地开发服务-createserver"><a href="#本地开发服务-createserver" class="header-anchor">#</a> 本地开发服务 - <code>createServer</code></h3> <p>回到 <code>createServer</code> 方法，该方法通过 <code>resolveConfig</code> 拿到配置后，第一时间处理了 <code>ssr</code>（服务端渲染）的逻辑。
如果使用了服务端渲染，则会通过别的方式进行本地开发调试;如果不是服务端渲染，则会创建一个 <code>http server</code> 用于本地开发
调试，同时创建一个 <code>websocket</code> 服务用于热重载。（如下图）
<img src="/webLearningRecord/assets/img/16.707027e8.png" alt="image"></p> <h4 id="文件监听-热重载"><a href="#文件监听-热重载" class="header-anchor">#</a> 文件监听 + 热重载</h4> <p>然后，<code>vite</code> 创建了一个 <code>FSWatcher</code> 对象，用于监听本地项目文件的变动。（这里使用的是 <code>chokidar</code> 库）</p> <div class="language-ts extra-class"><pre class="language-ts"><code>  <span class="token keyword">const</span> watcher <span class="token operator">=</span> chokidar<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    ignored<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token comment">// 忽略 node_modules 目录的文件变更</span>
      <span class="token string">'**/node_modules/**'</span><span class="token punctuation">,</span>
      <span class="token comment">// 忽略 .git 目录的文件变更</span>
      <span class="token string">'**/.git/**'</span><span class="token punctuation">,</span>
      <span class="token comment">// 忽略用户传入的 `ignore` 目录文件的变更</span>
      <span class="token operator">...</span><span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>ignored<span class="token punctuation">)</span> <span class="token operator">?</span> ignored <span class="token operator">:</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    ignoreInitial<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    ignorePermissionErrors<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    disableGlobbing<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>watchOptions
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">as</span> FSWatcher
</code></pre></div><p>然后，<code>vite</code> 将多个属性和方法组织成了一个 <code>server</code> 对象，该对象负责启动本地开发服务，也负责服务后续的开发热重载。</p> <p>接下来，我们看看 <code>watcher</code> 是如何做页面热重载的吧，原理就是监听到文件变更后，重新触发插件编译，然后将更新消息发送给客户端。（如下图）
<img src="/webLearningRecord/assets/img/17.2e44e084.png" alt="image"></p> <h4 id="插件容器"><a href="#插件容器" class="header-anchor">#</a> 插件容器</h4> <p>接下来，<code>vite</code> 创建了插件容器（<code>pluginContainer</code>），用于在构建的各个阶段调用插件的钩子。（如下图）
<img src="/webLearningRecord/assets/img/18.6d859fce.png" alt="image"></p> <blockquote><p>实际上插件容器是在热重载之前创建的，为了方便阅读，文章将热重载的内容都放在了一起。</p></blockquote> <h4 id="中间件机制"><a href="#中间件机制" class="header-anchor">#</a> 中间件机制</h4> <p>接下来是一些内部中间件的处理，当配置开发服务器选项时，<code>vite</code> 内部通过 <code>connect</code> 框架的中间件能力来提供支持。（如下图）
<img src="/webLearningRecord/assets/img/19.9e3a9ed6.png" alt="image">
其中，对 <code>public</code> 目录、公共路径等多项配置都是通过 <code>connect</code> + 中间件实现的，充分地利用了第三方库的能力，而没有重复造轮子。</p> <h4 id="预构建依赖"><a href="#预构建依赖" class="header-anchor">#</a> 预构建依赖</h4> <p>接下来，<code>vite</code> 内部对项目中使用到的依赖进行的预构建，一来是为了兼容不同的 ES 模块规范，二来是为了提升加载性能。（如下图）
<img src="/webLearningRecord/assets/img/20.c8ba9105.png" alt="image">
准备工作就绪后，<code>vite</code> 内部调用 <code>startServer</code> 启动本地开发服务器。（如下）</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// ...</span>
httpServer<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> host<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  httpServer<span class="token punctuation">.</span><span class="token function">removeListener</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> onError<span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看出，在本地开发时，<code>vite</code> 主要依赖 <code>插件 + 中间件体系</code> 来提供能力支持。因为本地开发时只涉及到少量编译工作，所以非常的快。只
有在构建生产产物时，<code>vite</code> 才用到了 <code>rollup</code> 进行构建。</p> <p>我们用一张流程图来最后梳理一遍 <code>vite 本地开发服务</code> 内部的工作流程吧
<img src="/webLearningRecord/assets/img/21.7b39f17b.png" alt="image"></p> <p><a href="https://blog.csdn.net/qq_34621851/article/details/123130837" target="_blank" rel="noopener noreferrer">vite build请参考这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="vite快还是慢"><a href="#vite快还是慢" class="header-anchor">#</a> vite快还是慢</h2> <p>谈到 Vite，给人的第一印象就是 dev server 启动速度快。同样规模的项目，相比 Webpack 动辄十几秒甚至几十秒的的启动速度，Vite 简直是快到没朋友，往往数秒之内即可完成启动，虽然也出现了
一些诸如首屏、懒加载性能下降等负面效果，但整体来说依然利大于弊，开发幸福感提升非常明显</p> <h3 id="vite的快"><a href="#vite的快" class="header-anchor">#</a> vite的快</h3> <p>Vite 的快，主要体现在两个方面: 快速的冷启动和快速的热更新。而 Vite 之所以能有如此优秀的表现，完全归功于 Vite 借助了浏览器对 ESM 规范的支持，采
取了与 Webpack 完全不同的 unbundle 机制</p> <p>首先要说的是webpack之所以能够大行其道，归功于它划时代的采用了 bundle 机制。通过这种 bundle 机制，Webpack 可以将项目中各种类型的源文件转化供浏览
器识别的 js、css、img 等文件，建立源文件之间的依赖关系，并将数量庞大的源文件合并为少量的几个输出文件</p> <p>bundle 工作机制的核心部分分为两块：构建模块依赖图 - module graph 和将 module graph 分解为最终供浏览器使用的几个输出文件</p> <h4 id="构建-module-graph-的过程可以简单归纳为"><a href="#构建-module-graph-的过程可以简单归纳为" class="header-anchor">#</a> 构建 module graph 的过程可以简单归纳为:</h4> <ol><li>获取配置文件中 entry 对应的 url (这个 url 一般为相对路径);</li> <li>resolve - 将 url 解析为绝对路径，找到源文件在本地磁盘的位置，并构建一个 module 对象；</li> <li>load - 读取源文件的内容;</li> <li>transform - 使用对应的 loader 将源文件内容转化为浏览器可识别的类型；</li> <li>parse - 将转化后的源文件内容解析为 AST 对象，分析 AST 对象，找到源文件中的静态依赖(import xxx from 'xxx') 和动态依赖(import('xx'))对应的 url, 并收集到 module 对象中；</li> <li>遍历第 5 步收集到的静态依赖、动态依赖对应的 url，重复 2 - 6 步骤，直到项目中所有的源文件都遍历完成。</li></ol> <h4 id="分解-module-graph-的过程也可以简单归纳为"><a href="#分解-module-graph-的过程也可以简单归纳为" class="header-anchor">#</a> 分解 module graph 的过程也可以简单归纳为:</h4> <ol><li>预处理 module graph，对 module graph 做 tree shaking；</li> <li>遍历 module graph，根据静态、动态依赖关系，将 module graph 分解为 initial chunk、async chunks；</li> <li>优化 initial chunk、 async chunks 中重复的 module；</li> <li>根据 optimization.splitChunks 进行优化，分离第三方依赖、被多个 chunk 共享的 module 到 common chunks 中；</li> <li>根据 chunk 类型，获取对应的 template；</li> <li>遍历每个 chunk 中收集的 module，结合 template，为每个 chunk 构建最后的输出内容；</li> <li>将最后的构建内容输出到 output 指定位置；</li></ol> <p>Webpack 的这种 bundle 机制，奠定了现代静态打包器(如 Rollup、Parcel、Esbuild)的标准工作模式</p> <p>然而成也萧何败萧何，强大的 bundle 机制，也引发了构建速度缓慢的问题，而且项目规模越大，构建速度越是缓慢。其主要原因是构建 module graph 的过程中，涉及到大量的文
件 IO、文件 transfrom、文件 parse 操作；以及分解 module graph 的过程中，需要遍历 module graph、文件 transform、文件 IO 等。这些操作，往往需要消耗大量
的时间，导致构建速度变得缓慢</p> <p>开发模式下，dev server 需要 Webpack 完成整个工作链路才可以启动成功，这就导致构建过程耗时越久，dev server 启动越久。为了加快构建速度，Webpack 也做了大量的优
化，如 loader 的缓存功能、webpack5 的持久化缓存等，但这些都治标不治本，只要 Webpack 的核心工作机制不变，那 dev server 启动优化，依旧是一个任重道远的过
程(基本上永远都达不到 Vite 那样的效果)</p> <h4 id="vite-之所以在-dev-server-启动方面，如此给力，是因为它采取了与-webpack-截然不同的-unbundle-机制"><a href="#vite-之所以在-dev-server-启动方面，如此给力，是因为它采取了与-webpack-截然不同的-unbundle-机制" class="header-anchor">#</a> Vite 之所以在 dev server 启动方面，如此给力，是因为它采取了与 Webpack 截然不同的 unbundle 机制</h4> <ol><li>不需要构建、分解 module graph，源文件之间的依赖关系完全通过浏览器对 ESM 规范的支持来解析</li> <li>dev server 端会通过 middlewares 对请求做拦截，然后对源文件做 resolve、load、transform、parse 操作，然后再将转换以后的内容发送给浏览器</li> <li>不对源文件做合并捆绑操作</li></ol> <p>webpack 启动以后，会 watch 源文件的变化。当源文件发生变化后，Webpack 会重新编译打包。这个时候，由于我们只修改了一个文件，因此只需要对这个源文件做 resolve、 load、 transfrom、parse 操作，依赖
的文件直接使用缓存，因此 dev server 的响应速度比冷启动要好很多;dev server 重新编译打包以后，会通过 ws 连接通知浏览器去获取新的打包文件，然后对页面做局部更新</p> <p>Vite 采用 unbundle 机制，所以 dev server 在监听到文件发生变化以后，只需要通过 ws 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了所以热更新速度很快</p> <h3 id="vite的慢"><a href="#vite的慢" class="header-anchor">#</a> vite的慢</h3> <p>由于 unbundle 机制，首屏期间需要额外做以下工作:</p> <ol><li>不对源文件做合并捆绑操作，导致大量的 http 请求；</li> <li>dev server 运行期间对源文件做 resolve、load、transform、parse 操作；</li> <li>预构建、二次预构建操作也会阻塞首屏请求，直到预构建完成为止；</li></ol> <p>和 Webpack 对比，Vite 把需要在 dev server 启动过程中完成的工作，转移到了 dev server 响应浏览器请求的过程中，不可避免的导致首屏性能下降。
不过首屏性能差只发生在 dev server 启动以后第一次加载页面时发生。之后再 reload 页面时，首屏性能会好很多。原因是 dev server 会将之前已经完成转换的内容缓存起来</p> <p>同样的， Vite 在懒加载方面的性能也比 Webpack 差。此外，如果懒加载过程中，发生了二次预构建，页面会 reload，对开发体验也有一定程度的影响</p> <h2 id="vite使用esbuild"><a href="#vite使用esbuild" class="header-anchor">#</a> vite使用esbuild</h2> <p>我们提到过开发模式下使用 Vite 会有首屏性能下降的负面效果。之所以会造成首屏性能下降</p> <ul><li>一方面是 dev server 需要完成预构建才可以响应首屏请求；</li> <li>另一方面是需要对请求文件做实时转换。
那么我们就从这两个方面来做优化，vite也是这么做的；Vite借助了 Esbuild 能快速完成项目打包、文件转换的能力来进行预构建、内容转换</li></ul> <p>Esbuild 是一款基于 Go 语言开发的 javascript 打包工具，最大的一个特征就是快，同样规模的项目，使用 Esbuild 可以将打包速度提升 10 - 100 倍，这对广大一直饱受 Webpack 缓慢打
包速度折磨的开发人员来说，简直就是福音，而 Esbuild 之所以能这么快，主要原因有两个:</p> <ul><li>Go 语言开发，可以多线程打包，代码直接编译成机器码；Webpack 一直被人诟病构建速度慢，主要原因是在打包构建过程中，存在大量的 resolve、load、transform、parse 操作
而这些操作通常是通过 javascript 代码来执行的。要知道，javascript 并不是什么高效的语言，在执行过程中要先编译后执行，还是单线程并且不能利用多核 cpu 优势，和 Go 语言相比，效率很低</li> <li>可充分利用多核 cpu 优势</li></ul> <h4 id="关键-api-transfrom-build"><a href="#关键-api-transfrom-build" class="header-anchor">#</a> 关键 API - transfrom &amp; build</h4> <p>Esbuild 并不复杂。它对外提供了两个 API - transform 和 build，使用起来非常简单。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// transfrom将ts、jsx、tsx等格式的内容转化为js,只负责文件内容转换，并不生成一个新的文件</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> esbuild<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token comment">// 将 code 转换为指定格式的内容</span>
<span class="token comment">// build根据指定的单个或者多个入口，分析依赖，并用loader将不同格式的内容转化为js内容，生成一个或多个 bundle 文件</span>
esbuild<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token comment">// 打包构建</span>
</code></pre></div><p>和 Webpack、Rollup 等构建工具一样，Esbuild 也提供了供外部使用的 plugin，使得我们可以介入构建打包过程</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> customerPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">setup</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">build</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解析 url 时触发，可自定义 url 如何解析。如果 callback 有返回 path，后面的同类型 callback 将不会执行</span>
        <span class="token comment">// 所有的 onResolve callback 将按照对应的 plugin 注册的顺序执行</span>
        build<span class="token punctuation">.</span><span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> filter<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span> namespace<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">args</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// onLoad, 加载模块时触发，可自定义模块如何加载。 如果 callback 有返回 contents，后面的同类型 callback 将</span>
        <span class="token comment">// 不会执行。所有的 onLoad callback 将按照对应的 plugin 注册的顺序执行</span>
        build<span class="token punctuation">.</span><span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">{</span> filter<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span> namespace<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">args</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// onStart, 每次 build 开始时都会触发，没有入参，因此不具有改变 build 的能力。多个 plugin 的 onStart 并行执行</span>
        build<span class="token punctuation">.</span><span class="token function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// onEnd, 每次 build 结束时会触发，入参为 build 的结果，可对 result 做修改。所有的的 onEnd 将按照对应的 plugin 注册的顺序执行</span>
        build<span class="token punctuation">.</span><span class="token function">onEnd</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>先来回顾一下为什么要做预构建,原因有两点:</p> <ul><li>将非 ESM 规范的代码转换为符合 ESM 规范的代码</li> <li>将第三方依赖内部的多个文件合并为一个，减少 http 请求数量</li></ul> <p>要完成预构建，最关键的两点是找到项目中所有的第三份依赖和对第三方依赖做合并、转换。借助 Esbuild，Vite 很轻松的实现了这两个诉求</p> <p>寻找第三方依赖的过程非常简单，分为两步:</p> <ol><li>定义一个带 onResolve hook 和 onLoad hook 的 esbuild plugin；</li> <li>执行 esbuild 的 build 方法做打包构建；</li></ol> <p>和 Webpack、Rollup、Parcel 等构建工具一样，Esbuild 在做打包构建时也要构建模块依赖图 - module graph；在构建 module graph 时，
第一步就是解析模块的绝对路径，这个时候就会触发 onResolve hook。在 onResolve hook 触发时，会传入模块的路径。根据模块的路径，我们
就可以判断出这个模块是第三方依赖还是业务代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.tsx</span>
<span class="token keyword">import</span> react <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> CustomeComponent <span class="token keyword">from</span> <span class="token string">'./components/CustomeComponent'</span><span class="token punctuation">;</span>
</code></pre></div><p>解析 react、CustomeComponent 时，会触发 onResolve hook，入参分别为 'react' 和 './components/CustomeComponent'。根据入参，我们
可以很清楚的区分 'react' 是第三方依赖，'./components/CustomeComponet' 是业务代码。这样，esbuild 完成构建，项目中的第三方依赖也就收集
完毕了。所有的第三方依赖会收集到一个 deps 列表中。</p> <p>知道了项目中的第三方依赖以后，再做合并、转换操作就非常简单了。这一步， Vite 直接通过 esbuild 提供的 build 方法，指定 entryPoints 为收集
到的第三方依赖，format 为 esm，再做一次打包构建。这一次，会对第三方依赖做合并、转换操作。打包构建完成以后，再把构建内容输出到 /node_modules/.vite/deps 下。</p> <h4 id="middlewares-中内容转换"><a href="#middlewares-中内容转换" class="header-anchor">#</a> middlewares 中内容转换</h4> <p>Vite 中源文件的转换是在 dev server 启动以后通过 middlewares 实现的。当浏览器发起请求以后，dev sever 会通过相应的 middlewares 对请求
做处理，然后将处理以后的内容返回给浏览器。middlewares 对源文件的处理，分为 resolve、load、transform、parser 四个过程：</p> <ol><li>resolve - 解析 url，找到源文件的绝对路径；</li> <li>load - 加载源文件。如果是第三方依赖，直接将预构建内容返回给浏览器；如果是业务代码，继续 transform、parser。</li> <li>transfrom - 对源文件内容做转换，即 ts -&gt; js, less -&gt; css 等。转换完成的内容可以直接返回给浏览器了。</li> <li>parser - 对转换以后的内容做分析，找到依赖模块，对依赖模块做预转换 - pre transform 操作，即重复 1 - 4。</li> <li>pre transform 是 Vite 做的一个优化点。预转换的内容会先做缓存，等浏览器发起请求以后，如果已经完成转换，直接将缓存的内容返回给浏览器。</li></ol> <p>Vite 在处理步骤 3 时，是通过 esbuild.transform 实现的，对比 Webpack 使用各个 loader 处理源文件，那是非常简单、快捷的</p> <h2 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h2> <p>在实际开发使用过程中，我们会发现一些问题和不足，这里做些记录</p> <h3 id="懒加载性能变差"><a href="#懒加载性能变差" class="header-anchor">#</a> 懒加载性能变差</h3> <p>性能差仅限于 dev server 启动以后首次打开应用的某一个页面，原因有两点：</p> <ul><li>大量的 http 请求</li> <li>dev server 实时对浏览器请求的文件做 transform</li></ul> <p>http 请求数量多这个问题，影响较小，因此只重点关注源文件实时处理这个问题。解决方案也很简单，就是在用户点击某个页面之前，提前向 dev server 发起请求，让 dev server 提前去
对请求文件做 transform,等到真正需要加载某个资源时，直接返回已经 transform 的资源。这种手段也就是我们常说的 prefetch。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用于提前获取首屏资源</span>
<span class="token operator">&lt;</span>link ref<span class="token operator">=</span><span class="token string">&quot;preload&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;xxxxx&quot;</span> <span class="token keyword">as</span><span class="token operator">=</span><span class="token string">&quot;script&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>

<span class="token comment">// 用于提前获取非首屏资源</span>
<span class="token operator">&lt;</span>link ref<span class="token operator">=</span><span class="token string">&quot;prefetch&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;xxxx&quot;</span>  <span class="token keyword">as</span><span class="token operator">=</span><span class="token string">&quot;script&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>

<span class="token comment">// 用于提前建立 http 连接</span>
<span class="token operator">&lt;</span>link ref<span class="token operator">=</span><span class="token string">&quot;preconnect&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;xxx&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>使用 prefetch 策略，有两个问题需要解决:</p> <ol><li>找到项目中需要懒加载的 path；</li> <li>将 prefetch 链接添加到 html 文件中；</li></ol> <p>首先是找到项目需要懒加载的 path。要完成这一步，有简单的实现，也有复杂的实现。简单的方式，就是开发人员手动定义一个需要 prefetch 的懒加载 path 列表。这种方式简单易用,方便快捷，而且使用
灵活，但是会加重开发人员的维护成本;复杂的方式，是通过技术手段实现。这种方式，和预加载需要提前获取项目中所有的第三方依赖一样，通过对项目整个源文件做一个依赖分析，然后识别出其中需要懒加载
的 path。因此我们可以像预加载一样，借助 esbuild 实现。但是这种方式有一个很大的问题，那就是由于我们需要把识别的 path 添加到 html 中，导致识别过程必须在浏览器请求 html 之前完成，这
就存在阻塞浏览器首屏请求的可能，使得首屏性能下降。综合两种方式的优劣和实现成本，采用第一种方式</p> <p>把 prefetch 链接添加到 html 文件中就非常简单了，我们可以通过 Vite 提供的 transformIndexHtml hook 实现。这个 hook 给我们提供了在 dev server 返回 html 文件之前修改 html 的机会</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// PrefetchLazyPathsPlugin.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">PrefetchLazyPathsPlugin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">paths<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">'prefetch-lazy-paths-plugin'</span><span class="token punctuation">,</span>
        <span class="token keyword">async</span> <span class="token function">transformIndexHtml</span><span class="token punctuation">(</span><span class="token parameter">html<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>paths<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> html<span class="token punctuation">;</span>
            <span class="token keyword">let</span> prefetchStr<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
            paths<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                prefetchStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;link rel=&quot;prefetch&quot; href=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; as=&quot;script&quot; /&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> newHtml <span class="token operator">=</span> html<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'&lt;/head&gt;'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prefetchStr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/head&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> newHtml<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// vite.config.ts</span>
<span class="token keyword">const</span> lazyPaths <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'/src/pages/order-manage/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token string">'/src/pages/customer-manage/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token string">'/src/pages/customer-group/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
<span class="token punctuation">]</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token function">PrefetchLazyPathsPlugin</span><span class="token punctuation">(</span>lazyPaths<span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>测试可以看到我们的优化策略是生效的，而且效果也非常不错，但是却带来一个很严重的问题,那就是首屏性能更差了。主要是 prefetch 策略使得 dev server 需要在首屏期间需要同时处理首屏资源 + 懒加载页面
资源，导致首屏资源的响应速度变慢，使得首屏性能下降。这样子的性能优化肯定是没有意义的，我们不能牺牲首屏性能去提升懒加载性能。后来考虑在首屏完成以后通过 fetch API去 prefetch</p> <p>通过 Vite 提供的 transform hook 实现。这个 hook 给我们提供了在 dev server 返回 transform 以后的代码之前，修改代码的机会。通过这个 hook，我们可以在入口文件
/src/index.tsx 完成 transform 以后、返回浏览器之前注入 fetch 代码</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// PrefetchLazyPathsPlugin.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">PrefetchLazyPathsPlugin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">entry<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> paths<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">'prefetch-lazy-paths-plugin'</span><span class="token punctuation">,</span>
        <span class="token keyword">async</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 只对入口文件做代码注入</span>
            <span class="token comment">// onload 会在页面所有资源加载完毕以后触发，这样我们就可以在 onload 内部调用 fetch 去实现 prefetch</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
                    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
                    window.onload = () =&gt; {
                        const lazyPages = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>paths<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
                        lazyPages.forEach(item =&gt; fetch(item));
                    }
                </span><span class="token template-punctuation string">`</span></span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> code<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// vite.config.ts</span>
<span class="token keyword">const</span> lazyPaths <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'/src/pages/order-manage/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token string">'/src/pages/customer-manage/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token string">'/src/pages/customer-group/index.tsx'</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
<span class="token punctuation">]</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token function">PrefetchLazyPathsPlugin</span><span class="token punctuation">(</span><span class="token string">'/src/index.tsx'</span><span class="token punctuation">,</span> lazyPaths<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这次优化以后，首屏性能不像上一次那么差，懒加载性能也非常优秀，但依然存在一个问题，那就是首个懒加载页面展示特别慢,我们还是简单做一下分析。整个首页的加载过程为:</p> <ol><li>首屏加载；</li> <li>prefetch 懒加载资源；</li> <li>根据当前路由懒加载 order-manage 页面</li></ol> <p>prefetch 导致 dev-server 需要同时处理 order-manage 页面资源 + 其他懒加载页面资源，导致 order-manage 资源响应速度变慢，使得 order-manage 页面渲染速度变慢。
最好的是在首页懒加载完成以后再去 prefetch</p> <ol><li>如何量化懒加载已经完成 ？</li> <li>用户首页懒加载的页面无法确定，我们怎么注入 prefetch 代码 ？</li></ol> <p>针对这个问题，目前没有特别好的解决方案，只能给每个懒加载页面都注入 prefetch 代码；人为通过 setTimeout 延迟 1000 ms 去 prefetch 来防止首个懒加载页面资源响应速度变慢</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// PrefetchLazyPathsPlugin.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">PrefetchLazyPathsPlugin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">paths<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> timeout<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">'prefetch-lazy-paths-plugin'</span><span class="token punctuation">,</span>
        <span class="token keyword">async</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>paths<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> path <span class="token keyword">of</span> paths<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
                            </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
                            const lazyPages = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>paths<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
                            setTimeout(() =&gt; {
                              lazyPages.forEach(item =&gt; fetch(item));
                            }, timeout);
                        </span><span class="token template-punctuation string">`</span></span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> code<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webLearningRecord/vite/prelearn.html" class="prev">
        基础知识
      </a></span> <span class="next"><a href="/webLearningRecord/react/react.html">
        react初探
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/webLearningRecord/assets/js/app.bdc4d5ac.js" defer></script><script src="/webLearningRecord/assets/js/2.1a231426.js" defer></script><script src="/webLearningRecord/assets/js/6.d3f0121d.js" defer></script>
  </body>
</html>
